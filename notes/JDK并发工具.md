# 1. 同步控制

## 1.1 重入锁

重入锁可以完全替代synchronized关键字。在JDK5.0前，重入锁的性能是好于synchronized关键字的，但是自JDK6.0后，JDK对synchronized做了大量优化，所以现在二者性能差距不大。

1. 重入锁相较于synchronized，有着显式的操作过程，需要手动操作何时加锁，何时释放锁，所以更加灵活。但要记住手动释放锁，不然其他线程就不能访问临界区了。
2. 重入锁是之所以叫重入，是因为这种锁是可以反复进入的。 当一个线程多次获得锁的时候，在释放锁的时候就必须释放相同次数的锁。如果释放次数过多，会导致异常，释放次数过少，线程仍然持有锁，其他线程无法进入临界区。 
```Java
    lock.lock()；
    lock.lock()；
    lock.lock()；
    lock.unlock()；
    lock.unlock()；
    lock.unlock()；
```   
3. 重入锁可以处理中断响应，中断后，线程会退出。采用重入锁，可以有效地避免死锁问题。
4. 限时等待也可以避免死锁，使用tryLock()进行一次限时的等待。如果有参数，即为等待时长和计时单位。如果括号内没有参数，表示申请锁成功就会返回true，反之就会立即返回false。
5. 公平锁：在大部分情况下，锁都是不公平的。系统会从锁的等待队列中随机选择一个。而公平锁就是按照线程到达等待序列的前后顺序，因此公平锁不会产生饥饿现象。由于公平锁需要系统维护一个有序的队列，因此实现成本较高且性能相对低下。
6. condition条件：condition与重入锁想关联，通过重入锁的Lock接口中的newCondition()方法就可以生成一个Condition实例。通过Condition实例可以让线程在合适的时间进行等待或者继续执行。

```java
condition配合重入锁使用，方法为condition.await()和condition.signal().

Object中的wait()和notify()配合synchronized使用。

上述方法执行时均需要获得锁。
```

## 1.2 读写锁

对于读操作来说，并不会对数据的完整性造成破坏，因此所有读之间也需要等待锁，这种设计是不合理的。因此，读写分离锁(ReadWriteLock)可以有效的减少锁竞争。在系统中，读操作要远远大于写操作，则读写锁可以发挥最大的功效，提升系统的性能。

## 1.3 倒计时器和循环栅栏

## 1.4 线程阻塞类工具LockSupport

**LockSupport是一个线程阻塞工具，他可以在线程内的任意位置对线程进行阻塞。**


其静态方法park()可以阻塞线程，其原理是LockSupport给每一个线程准备了一个许可，如果许可可用，则park()会立即返回，并且将许可变为不可用。当许可为不可用时，线程就阻塞了。同时，还有parkNanos()和parkUntil()等，在许可可用前禁用当前线程，并最多等待指定的等待时间。除了有定时阻塞的功能，LockSupport.park( )还能支持中断影响，但是不会抛出InterruptedException异常。而unpark()则是将许可变为可用，但是这个许可不可叠加，永远只有一个，因此如果unpark()出现在park()之前，也可以使park()顺利结束。
```
对比Thread.suspend():他弥补了由于resume发生在前，线程无法继续执行的情况。同时，处于park()状态的线程会在jstack中明确给出一个WAITING状态，并标明阻塞对象。
对比Object.wait():它不需要先获得某个对象的锁，也不会抛出InterruptedException异常。
```

## 1.5 信号量(semaphore)
一般默认一个线程一次访问一个资源。通过信号量可以指定多个线程同时访问某一个资源。其主要方法有：acquire()和tryAcquire()以及release()方法。acquire方法尝试获得一个准入许可，如果无法获得就会一直等待。release()方法可以在线程访问完资源后释放许可，使得其他线程可以进行资源访问。

# 2. 线程池



# 3. JDK并发容器
