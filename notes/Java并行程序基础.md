# 1. 进程（process）
1. 定义：进程是计算机程序中关于某数据集合上的一次运行活动。<font color = #FF0000>**s是系统进行资源分配和调度的基本单位，是操作系统结构的基础。**</font>
2. 线程与进程关系：  
    线程是轻量级进程，是程序执行的最小单位。
    
    ``` 
    Q:为什么要用多线程而不是多进程？
    A：线程间的调度和切换成本要远远小于进程。
    ```

# 2. 线程（Thread）
1. 线程的生命周期：  

    - NEW： 刚刚创建的线程，还没开始执行
    - Runable：线程的start()方法执行后，线程开始执行
    - Blocked：当线程遇到synchronized同步块，进入阻塞状态，线程暂停执行，直到获得请求的锁
    - Waiting：进入一个无限时间的等待
    - Timed-waiting：进入一个有限长时间的等待
    - Terminated： 线程执行完毕，进行结束状态。
    ```
    Q1:wait和sleep的区别：
    A1：
        1.wait是Object类中的方法，而sleep是Thread里的静态方法； 
        2.wait可以通过notify/notifyAll唤醒，而sleep会自动唤醒，如果要强制唤醒，可使用interrupt方法强行打断。
        3.wait会释放锁资源，进入线程等待池，让出系统资源；而sleep不会释放锁
        4.sleep可以在任何地方使用；而wait，notify，notifyAll只能在同步控制方法或者同步控制块中使用。
        5.sleep必须捕获异常；而wait，notify，notifyAll的不需要捕获异常。

    ```
2. 线程的基本操作

    - 线程的新建

        使用new关键词之后并将其start()起来。如果不采用start()而是直接执行新建线程里的run()方法，就只是一个普通的方法调用。新建线程常见有两种方法，分别为：①通过继承Thread类，重载run()方法来自定义线程。②使用Runable接口来重载run方法创建线程。

        **也可以通过调用callable接口来新建线程。**

    - 线程的终止
        
        除了线程运行完成自己结束外，还可以使用Thread.stop()进行线程的终止。但需要注意**stop()方法会直接终止线程，并且会立即释放该线程持有的锁。因此可能会出现读取的数据出现不一致的现象。**

    - 线程的中断

        - Thread.interrupt()：为一个实例方法，通知目标线程中断，设置中断标志位，表示当前线程已经被中断。
        - Thread.isInterrupted()：也是一个实例方法，判断当前线程是否被中断（通过检查中断标志位）
        - Thread.interrupted()：静态方法，也能用来判断当前线程的中断状态，但同时会清除当前线程的中断标志位状态。


    - wait和notify

        这两个接口均为Object类中的方法，也就是说任意的对象都可以调用这两个接口。且使用这两个方法前都需要获取目标的监视器。

         - wait():调用该方法后，线程就会转为等待状态，并且释放监视器，并且让该对象进入等待队列，且wait()方法必须包含在对应的synchronzied语句中。

         - notify()/notifyAll()： 使用notify()后，系统会从等待队列中随机选择一个线程将其唤醒，并没有先等待的线程先唤醒。而notifyAll()则会唤醒等待队列里的所有线程。



    - suspend和resume  

        **这两个接口都已被标注为废弃，不推荐使用。**
        
        - suspend() : 将线程挂起，并不释放任何锁资源，因此等待该锁的其他线程都会被影响，无法正常工作。

        -  resume() : 使挂起的线程继续执行。
        
        **注意：如果resume（）在suspend（）前已经执行，那么被挂起的线程就很难继续执行，并且不会对锁资源进行释放，使得整个系统工作不正常，且此时通过线程状态查看，被挂起的线程状态仍为Runnable。** 

    - join和yield  
        线程之间的协作和人与人之间的关系相似，有些线程的运行十分依赖于其他线程的结果。只有等待依赖线程执行完毕后才能继续执行。  

        - join(long mills)：表示线程需要等待依赖线程执行完成后才能继续执行。如果join里的括号为空，则为无限等待，会一直阻塞线程。而如果里面有long型数字，则给出了最大等待时间，超过这个时间后线程会继续往下执行。

         *注意：join的本质是通过调用wait()方法实现的，因此在等待线程上不要使用类似wait()或者notify()等方法，以免相互干扰。*
        
        - yield() : 其为静态方法，一旦执行，它会让当前线程让出cpu给其他线程，但是当前线程仍会进行cpu资源的争夺，有可能会再次执行。

# 3. 线程组
1. 定义：当系统内线程数量很多，且功能分配明确，则可以将相同功能的线程放置在一个线程组里。

    *如果把线程比作苹果，那么线程组就是一个装着很多苹果的篮子。*

```java
//线程组的创建
ThreadGroup tg = new ThreadGroup("name");

//使用Thread创建线程，并指定线程的线程组，将其关联起来
Thread t1 = new Thread(tg , new ThreadName() implements Runnable , "T1")

//获得线程组中活动线程的总数
tg.activeCount();
//打印线程组中所有的线程信息
tg.list()
```

# 4.守护线程（Daemon）
守护线程在后台进行一些系统性的服务，例如垃圾回收线程，JIT线程。与之对应的是用户线程，用户线程可以认为是系统内的工作线程。因此如果一个Java程序里只有守护线程是，JVM就自然退出了。
```java
Thread t =new threadtest()
//设置t为守护线程，设置守护线程必须在start之前。
t.setDaemon(true)
```

# 5. synchronized关键字
1. 用法：

    - 指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁
    - 直接作用于实例方法：相当于给当前实例加锁，进入同步代码前要获得当前实例的锁
    - 直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁
```java
//synchronized与volatile：
/*
1.volatile不需要加锁，比synchronized更轻量级，不会阻塞线程，但volatile不能保证变量复合操作的原子性；
2.synchronized既能够保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。
*/

```

*注意：在Java语言中，不变对象（对象一旦被创建，就不可能被修改，如果要修改，就需要新建一个新的对象。）不能作为锁，如Integer，String等*
